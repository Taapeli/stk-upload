<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fi" lang="fi">
<head></head>
<!-- Heavily adapted from https://bl.ocks.org/d3noob/5537fe63086c4f100114f87f124850dd -->
<!-- Copyright (C) 2021 GSF (https://www.genealogia.fi/) Taapeli project and Heikki Roikonen -->
<body>
    <style>
        rect {
            stroke: blue;
            opacity: 0.75;
            stroke-width: 1;
        }
        .unknown_birth rect {
            rx: 5;
            ry: 5;
        }
        .unknown_death rect {
            rx: 5;
            ry: 5;
        }
        .unknown_both rect {
            rx: 5;
            ry: 5;
        }

        div {
            padding: 0px;
            margin: 0px;
        }

        text {
            fill: black;
            font-style: normal;
            font: 12px sans-serif;
            text-anchor: start;
        }
        .tick text {
            fill: black;
            text-anchor: middle;
        }
        .link {
            fill: none;
            stroke: green;
            opacity: 0.75;
            stroke-width: 1;
        }
    </style>    
<!-- load the d3.js library -->	
<script src="https://d3js.org/d3.v6.min.js"></script>
<script>

    var anc_data = JSON.parse('{{ ancestors|safe }}');
    var desc_data = JSON.parse('{{ descendants|safe }}');

    var margin = {top: 20, right: 90, bottom: 30, left: 90};
    const box_margin = '0.25em';
    const width = 1200 - margin.left - margin.right;
    const height = 600 - margin.top - margin.bottom;
    const axisoffset = 600;
    const rect_height = 15;
    const nudge_height = 3;
    const link_width = 7;
    const box_height = 60;
    const box_width = 150;

    const first_year = anc_data.oldest;
    const last_year = desc_data.newest;
    const ave_age = 75;
    const ave_gen_gap = 30;

    var yearScale = d3.scaleLinear()
        .domain([first_year, last_year])
        .range([-width/2, width/2]);

    var yearAxis = d3.axisBottom()
        .scale(yearScale)
        .tickFormat(d3.format(".0f"));

    // declares a tree layout and assigns the size
    var treelayout = d3.tree()
        .size([height, width]);

    // Create Event Handlers for mouse
    function handleClick(event, d) {
        if (d.data.uuid != null) {
            var searchParams = new URLSearchParams(window.location.search);
            searchParams.set('uuid', d.data.uuid);
            var newParams = searchParams.toString();
            window.location.search = newParams;
        }
        event.stopPropagation();
    }
    function handleMouseEnter(event, d) {
        const coords = d3.pointer(event);
        const box_x = coords[0] - box_width / 3,
              box_y = coords[1] - box_height / 2;

        d3.select("#isotammi_d3_infobox").remove();

        g = d3.select(this).append("g");

        g.attr("id", "isotammi_d3_infobox")
            .append("rect")
            .attr("x", box_x).attr("y", box_y)
            .attr("fill", "lightyellow")
            .style("opacity", "1.0")
            .attr("height", box_height)
            .attr("width", box_width);

        //     .attr('fill', d => d.data.too_new ? 'red' : 'black')

        g.append('foreignObject')
            .attr("x", box_x).attr("y", box_y)
            .attr('width', box_width)
            .attr('height', box_height)
            .append("xhtml:body")
            .html('<div>' +
                d.data.name + "<br>" + d.data.years + "<br>" + d.data.uuid + "<br>" +
                ("children" in d ? d.children.length : 0) +
                '</div>');

        d3.select(this)
            .raise();

        event.stopPropagation();
    }

    // calculate the x coordinates for the parents, leaving empty slots for missing parents
    // currently father is put to the top
    function ancestor_treelayout(root, midpoint = 275.0, depth = 0, gender = 0) {

        function offset(gender) {
            if (gender == 2)
                return -1
            else
                return gender;
        }

        root.x = midpoint + offset(gender) * 5 * nudge_height;
        root.depth = depth;

        if ("children" in root)
            root.children.forEach(function(child, index) {
                this[index] = ancestor_treelayout(child, root.x, depth + 1, child.gender);
            }, root.children);
        return root;
    }

    // append the svg object to the body of the page
    // appends a 'group' element to 'svg'
    // moves the 'group' element to the top left margin
    var svg = d3.select("body").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .style("fill", "lightyellow") //##### TEST #####
        .attr("viewBox", [-width*0.3, -height*1.1, width, height*1.5])
        .call(yearAxis);

    var draw = (this_data, root_node, anc) => {

        //  assigns the data to a hierarchy using parent-child relationships
        var nodes = d3.hierarchy(this_data, d => d.children);

        // maps the node data to the tree layout
        if (anc)
            nodes = ancestor_treelayout(nodes)
        else
            nodes = treelayout(nodes)
                .sort((a, b) => b.data.birth - a.data.birth);

        var g = svg.append("g")
            // .attr("transform",
            //     "translate(" + margin.left + "," + (margin.top + axisoffset) + ")")
            .attr("transform",
                "translate(" + 0 + "," + (-620 + (anc ? 0 : (root_node.x - nodes.x))) + ")");

        // adds the links between the nodes
        var link = g.selectAll(".link")
            .data(nodes.descendants().slice(1))
            .enter().append("path")
                .attr("class", "link")
                .attr("d", d => {
                    if (anc) {
                        own_height = d.x + rect_height / 2 /* - d.depth * nudge_height */
                                + Math.sign(d.parent.x - d.x) * rect_height/2;
                        return Math.abs(d.x - d.parent.x) /* + Math.sign(d.x - d.parent.x)*nudge_height */ < rect_height/2
                            ? null  // no connector if overlap
                            : "M" + yearScale(d.parent.data.birth) + "," + (d.parent.x + rect_height/2 /* - (d.depth - 1)*nudge_height */ )
                            + "C" + (yearScale(d.parent.data.birth) - link_width) + "," + (d.parent.x + rect_height/2 /* - (d.depth - 1)*nudge_height */ )
                            + " " + yearScale(d.parent.data.birth) + "," + own_height
                            + " " + (yearScale(d.parent.data.birth) - link_width) + "," + own_height;
                    } else {
                        parent_height = d.parent.x
                            + (d.x == d.parent.x ? rect_height/2 : 0)
                            + (d.x > d.parent.x ? rect_height : 0)
                            + (d.depth - 1) * nudge_height;
                        return Math.abs(d.x - d.parent.x) + Math.sign(d.x - d.parent.x)*nudge_height < rect_height/2
                            ? null  // no connector if overlap
                            : "M" + yearScale(d.data.birth) + "," + (d.x + rect_height/2 + d.depth*nudge_height)
                            + "C" + (yearScale(d.data.birth) - link_width) + "," + (d.x + rect_height/2 + d.depth*nudge_height)
                            + " " + yearScale(d.data.birth) + "," + parent_height
                            + " " + (yearScale(d.data.birth) - link_width) + "," + parent_height;
                    }
                });

        // adds each node as a group
        var node = g.selectAll(".node")
            .data(nodes.descendants())
            .enter().append("g")
                .attr("class", d => 
                    "node" + 
                    (d.children ? " node--internal" : " node--leaf")
                )
                .on("click", handleClick)
                .on("mouseenter", handleMouseEnter)
                .attr("transform", d => {
                    birth = (d.data.birth == 0)
                        ? d.parent.data.birth + ave_gen_gap * (anc ? -1 : 1)
                        : d.data.birth;
                    if (anc)
                        return "translate(" + yearScale(birth) + ","
                            + (d.x /* - d.depth * nudge_height */ ) + ")"
                    else
                        return "translate(" + yearScale(birth) + ","
                            + (d.x + d.depth * nudge_height) + ")"
                })
                .classed("unknown_birth", d => d.data.birth == 0)
                .classed("unknown_death", d => d.data.death == 0)
                .classed("unknown_both", d => d.data.birth == 0 && d.data.death == 0);

        // adds the rect to the node
        node.append("rect")
            .attr("fill", d => d.data.color)
            .attr("height", rect_height)
            .attr("width", d =>
                d.data.death == 0
                    ? yearScale(d.data.birth + ave_age) - yearScale(d.data.birth)
                : d.data.death == d.data.birth 
                    ? 1
                : yearScale(d.data.death) - yearScale(d.data.birth)
            );

        // adds the text to the node
        node.append("text")
            .attr("y", "1em")
            .attr("x", "0.3em")
            .text(d => d.data.name);

        return nodes;
    }

    // make sure the root nodes coincide
    root = draw(anc_data, null, anc=true);
    root = draw(desc_data, root, anc=false);

</script>
</body></html>
